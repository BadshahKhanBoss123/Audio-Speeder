<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Speeder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the game */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        canvas {
            display: block;
            background-color: #374151; /* gray-700 */
            border-radius: 0.375rem; /* rounded-md */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">

    <div class="bg-gray-800 rounded-lg shadow-xl p-6 relative overflow-hidden w-full max-w-4xl">
        
        <!-- Game Title -->
        <h1 class="text-3xl font-bold text-center mb-4">Audio Speeder</h1>
        <p class="text-center text-gray-400 mb-4">The quieter the sound, the faster you go! Use loud audio to slow down! Use your mouse to move up and down.</p>

        <!-- Game Container -->
        <div id="gameContainer" class="relative w-[800px] h-[600px] max-w-full mx-auto">
            <!-- Game Canvas -->
            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <!-- UI Overlay: Score -->
            <div class="absolute top-4 left-4 text-2xl font-bold text-white" style="text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                Score: <span id="scoreDisplay">0</span>
            </div>

            <!-- UI Overlay: Volume Meter -->
            <div class="absolute bottom-4 left-4 w-10 h-40 bg-gray-600 rounded-full overflow-hidden border-2 border-gray-500">
                <div id="volumeMeter" class="absolute bottom-0 w-full bg-gradient-to-t from-green-400 to-green-600 transition-all duration-75" style="height: 0%;"></div>
            </div>
            <div class="absolute bottom-4 left-16 text-sm text-gray-300">Volume</div>

            <!-- Modal: Start Game -->
            <div id="startModal" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center z-10 rounded-lg">
                <h2 class="text-4xl font-bold mb-4">Welcome to Audio Speeder!</h2>
                <p class="text-lg mb-4">Upload an audio file to play:</p>
                <input type="file" id="audioUpload" accept="audio/*" class="mb-4 text-sm text-gray-300
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-100 file:text-blue-700
                    hover:file:bg-blue-200 cursor-pointer">
                <p id="fileError" class="text-red-500 mb-4 hidden h-6"></p> <!-- Added height to prevent layout shift -->
                <button id="startButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg text-xl cursor-pointer transition-transform duration-150 active:scale-95 disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>
                    Select a file
                </button>
            </div>

            <!-- Modal: Game Over -->
            <div id="gameOverModal" class="absolute inset-0 bg-black bg-opacity-75 flex-col items-center justify-center z-10 rounded-lg hidden"> <!-- Initially hidden -->
                <h2 class="text-5xl font-bold mb-4 text-red-500">Game Over!</h2>
                <p class="text-2xl mb-4">Final Score: <span id="finalScore">0</span></p>
                <button id="restartButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg text-xl cursor-pointer transition-transform duration-150 active:scale-95">
                    Try Again
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const startModal = document.getElementById('startModal');
            const gameOverModal = document.getElementById('gameOverModal');
            const startButton = document.getElementById('startButton');
            const audioUpload = document.getElementById('audioUpload'); // NEW
            const fileError = document.getElementById('fileError'); // NEW
            const restartButton = document.getElementById('restartButton');
            const scoreDisplay = document.getElementById('scoreDisplay');
            const finalScore = document.getElementById('finalScore');
            const volumeMeter = document.getElementById('volumeMeter');

            // Game State
            let player, obstacles, cameraX, score, gameOver, mouseY, lastObstacleX, gameLoopId;
            
            // Audio State
            let audioContext, analyser, dataArray;
            let decodedAudioBuffer = null; // NEW
            let currentAudioSource = null; // NEW
            const SILENCE_THRESHOLD = 0; // No ambient noise from a file
            const MAX_VOLUME = 70; // Volume for max speed (0-255 scale)
            
            // Game Constants
            const PLAYER_RADIUS = 15;
            const PLAYER_COLOR = '#3B82F6'; // blue-500
            const OBSTACLE_COLOR = '#EF4444'; // red-500
            const OBSTACLE_WIDTH = 30;
            const OBSTACLE_HEIGHT = 120;
            const MIN_SPEED = 0.5; // Constant drift speed
            const MAX_SPEED = 15; // Speed at max volume

            function init() {
                // Hide modals
                startModal.classList.add('hidden');
                gameOverModal.classList.add('hidden');

                // Reset game state
                player = { x: 100, y: canvas.height / 2, radius: PLAYER_RADIUS };
                obstacles = [];
                cameraX = 0;
                score = 0;
                gameOver = false;
                mouseY = canvas.height / 2;
                lastObstacleX = 400; // Start spawning obstacles ahead
                scoreDisplay.textContent = '0';

                // Populate initial obstacles
                spawnObstacles();

                // Start audio playback from the buffer
                startAudioPlayback(); // MODIFIED

                // Stop any previous game loop
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                
                // Start the new game loop
                gameLoop();
            }

            function startAudioPlayback() {
                // Stop any existing audio source
                if (currentAudioSource) {
                    currentAudioSource.stop();
                    currentAudioSource.disconnect();
                }

                if (!decodedAudioBuffer) return; // Should not happen if button is enabled

                // Create a new source node
                currentAudioSource = audioContext.createBufferSource();
                currentAudioSource.buffer = decodedAudioBuffer;
                currentAudioSource.loop = true; // Loop the audio
                
                // Connect it to the (existing) analyser
                currentAudioSource.connect(analyser);
                
                // Start playing
                currentAudioSource.start(0);
            }

            async function setupAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);

                    analyser.fftSize = 128; // Smaller size for faster analysis
                    analyser.smoothingTimeConstant = 0.3; // Smooth out readings
                    const bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                } catch (err) {
                    console.error('Error accessing microphone:', err);
                    alert('Microphone access is required to play. Please allow access and refresh.');
                }
            }

            function getVolume() {
                if (!analyser) return 0;
                
                analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                let avg = sum / dataArray.length;
                return avg;
            }

            function spawnObstacles() {
                // Keep spawning obstacles two screens ahead of the player
                while (lastObstacleX < player.x + canvas.width * 2) {
                    const newX = lastObstacleX + 250 + Math.random() * 200;
                    const newY = Math.random() * (canvas.height - OBSTACLE_HEIGHT);
                    obstacles.push({
                        x: newX,
                        y: newY,
                        width: OBSTACLE_WIDTH,
                        height: OBSTACLE_HEIGHT
                    });
                    lastObstacleX = newX;
                }

                // Clean up obstacles far behind the camera
                obstacles = obstacles.filter(obs => obs.x + obs.width > cameraX);
            }

            function updateGame() {
                if (gameOver) return;

                // 1. Get volume and map to speed
                const volume = getVolume();
                const normalizedVol = Math.max(0, volume - SILENCE_THRESHOLD);
                const volumeRatio = Math.min(1, normalizedVol / (MAX_VOLUME - SILENCE_THRESHOLD));
                // REVERSED LOGIC: Loud = slow, Quiet = fast
                player.speedX = MAX_SPEED - (volumeRatio * (MAX_SPEED - MIN_SPEED));

                // Update volume meter UI
                volumeMeter.style.height = `${volumeRatio * 100}%`;

                // 2. Update player position
                player.x += player.speedX;
                player.y = mouseY;

                // 3. Update camera
                cameraX = player.x - 100; // Keep player 100px from left edge

                // 4. Update score
                score = Math.floor(player.x / 100);
                scoreDisplay.textContent = score;

                // 5. Spawn new obstacles if needed
                spawnObstacles();

                // 6. Check for collisions
                for (const obs of obstacles) {
                    // Simple AABB collision detection
                    const playerLeft = player.x - player.radius;
                    const playerRight = player.x + player.radius;
                    const playerTop = player.y - player.radius;
                    const playerBottom = player.y + player.radius;

                    const obsLeft = obs.x;
                    const obsRight = obs.x + obs.width;
                    const obsTop = obs.y;
                    const obsBottom = obs.y + obs.height;

                    if (playerRight > obsLeft && playerLeft < obsRight && playerBottom > obsTop && playerTop < obsBottom) {
                        endGame();
                        return;
                    }
                }
                
                // 7. Check canvas bounds
                if (player.y - player.radius < 0 || player.y + player.radius > canvas.height) {
                    endGame();
                    return;
                }
            }

            function drawGame() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Save context and translate for camera
                ctx.save();
                ctx.translate(-cameraX, 0);

                // Draw player
                ctx.fillStyle = PLAYER_COLOR;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw obstacles
                ctx.fillStyle = OBSTACLE_COLOR;
                for (const obs of obstacles) {
                    // Only draw obstacles that are on screen
                    if (obs.x + obs.width > cameraX && obs.x < cameraX + canvas.width) {
                        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    }
                }

                // Restore context
                ctx.restore();
            }

            function endGame() {
                gameOver = true;
                cancelAnimationFrame(gameLoopId);

                // Stop the music
                if (currentAudioSource) {
                    currentAudioSource.stop();
                }

                finalScore.textContent = score;
                gameOverModal.classList.remove('hidden');
                gameOverModal.classList.add('flex');
            }

            function gameLoop() {
                if (gameOver) return;
                
                updateGame();
                drawGame();
                
                gameLoopId = requestAnimationFrame(gameLoop);
            }

            // --- Event Listeners ---

            // Start button
            startButton.addEventListener('click', init);

            // Restart button
            restartButton.addEventListener('click', init);

            // Audio file upload listener
            audioUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                startButton.textContent = "Loading...";
                startButton.disabled = true;
                fileError.classList.add('hidden');
                
                try {
                    // Initialize AudioContext on user interaction
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const reader = new FileReader();
                    
                    reader.onload = (readEvent) => {
                        audioContext.decodeAudioData(readEvent.target.result)
                            .then(buffer => {
                                decodedAudioBuffer = buffer; // Store the decoded buffer
                                
                                // Setup analyser (only needs to be done once)
                                if (!analyser) {
                                    analyser = audioContext.createAnalyser();
                                    analyser.fftSize = 128;
                                    analyser.smoothingTimeConstant = 0.3;
                                    const bufferLength = analyser.frequencyBinCount;
                                    dataArray = new Uint8Array(bufferLength);
                                    
                                    // Connect analyser to output so we hear the music
                                    analyser.connect(audioContext.destination);
                                }

                                startButton.textContent = "Start Game";
                                startButton.disabled = false;
                            })
                            .catch(err => {
                                console.error('Error decoding audio data:', err);
                                fileError.textContent = 'Error: Could not decode audio file.';
                                fileError.classList.remove('hidden');
                                startButton.textContent = "Select a file";
                            });
                    };
                    
                    reader.onerror = () => {
                        console.error('Error reading file');
                        fileError.textContent = 'Error: Could not read file.';
                        fileError.classList.remove('hidden');
                        startButton.textContent = "Select a file";
                    };
                    
                    reader.readAsArrayBuffer(file);

                } catch (err) {
                    console.error('Error setting up audio:', err);
                    fileError.textContent = 'Error: Audio playback not supported.';
                    fileError.classList.remove('hidden');
                }
            });

            // Mouse move listener
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseY = e.clientY - rect.top;
            });
            
            // Adjust canvas size for responsiveness (simple scaling)
            function resizeCanvas() {
                const container = document.getElementById('gameContainer');
                const ratio = 600 / 800; // height / width
                let newWidth = container.clientWidth;
                let newHeight = newWidth * ratio;

                if (newHeight > container.clientHeight) {
                    newHeight = container.clientHeight;
                    newWidth = newHeight / ratio;
                }
                
                canvas.style.width = `${newWidth}px`;
                canvas.style.height = `${newHeight}px`;
            }
            
            // Note: The internal canvas resolution (800x600) stays the same,
            // but its display size scales. This is a common way to handle game canvases.
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial call
        });
    </script>
</body>
</html>